{% extends "base.html" %}

{% block title %}{{ bot.name }}{% endblock %}

{% block content %}
<div class="tool-container">
    <h1>{{ bot.name }}</h1>

    <form method="post" class="tool-form" enctype="multipart/form-data">
        {% if bot.id == "citation" %}
        <div class="form-group">
            <label>BibTeX Entry</label>
            <textarea name="bibtex" rows="10" required placeholder="Paste BibTeX here...">{{ last_values.bibtex or '' }}</textarea>
        </div>
        <div class="form-group">
            <label>Style</label>
            <select name="style">
                <option value="APA"     {% if last_values.style == 'APA'     %}selected{% endif %}>APA</option>
                <option value="IEEE"    {% if last_values.style == 'IEEE'    %}selected{% endif %}>IEEE</option>
                <option value="MLA"     {% if last_values.style == 'MLA'     %}selected{% endif %}>MLA</option>
                <option value="Chicago" {% if last_values.style == 'Chicago' %}selected{% endif %}>Chicago</option>
                <option value="Harvard" {% if last_values.style == 'Harvard' %}selected{% endif %}>Harvard</option>
                <option value="Vancouver" {% if last_values.style == 'Vancouver' %}selected{% endif %}>Vancouver</option>
            </select>
        </div>

        {% elif bot.id == "idea" %}
        <div class="form-group">
            <label>Field</label>
            <input type="text" name="field" value="{{ last_values.field or '' }}" required>
        </div>
        <div class="form-group">
            <label>Topic</label>
            <textarea name="topic" rows="4">{{ last_values.topic or '' }}</textarea>
        </div>
        <div class="form-group">
            <label>Novelty</label>
            <input type="text" name="novelty" value="{{ last_values.novelty or '' }}">
        </div>
        <div class="form-group">
            <label>Target Venue</label>
            <input type="text" name="target_venue" value="{{ last_values.target_venue or '' }}">
        </div>
        <div class="form-group">
            <label>Style</label>
            <input type="text" name="style_text" value="{{ last_values.style_text or '' }}">
        </div>

        {% elif bot.id == "conference" %}
        <div class="chat-only">
            <h3>Conference Chat</h3>
            <div id="chat-window" style="border:1px solid var(--border); padding:12px; border-radius:8px; height:360px; overflow:auto; background: #091018;">
                <!-- Messages will appear here -->
            </div>
            <div style="margin-top:0.8rem; display:flex; gap:8px;">
                <input type="text" id="chat-input" placeholder="Ask about this conference (e.g., dates, location, topics)..." style="flex:1; padding:0.6rem; border-radius:6px; background:var(--surface); border:1px solid var(--border); color:var(--text);">
                <button type="button" class="btn-primary" id="chat-send">Send</button>
            </div>
            <p style="color:#999; margin-top:6px;">Tip: This chat answers questions about the conference profile the bot is configured to use.</p>
        </div>

        {% elif bot.id == "writer" %}
        <div class="form-group">
            <label>Input Text</label>
            <textarea name="input_text" rows="8" placeholder="Provide text to generate/expand into an academic paragraph...">{{ last_values.input_text or '' }}</textarea>
        </div>

        {% elif bot.id == "reviewer" %}
        <div class="form-group">
            <label>PDF Upload</label>
            <input type="file" name="pdf_file" accept="application/pdf">
        </div>
        <div class="form-group">
            <label>PDF URL or local path</label>
            <input type="text" name="pdf_path" value="{{ last_values.pdf_path or '' }}" placeholder="https://... or C:/path/to/file.pdf">
        </div>
        <div class="form-group">
            <label>Question / Instruction</label>
            <textarea name="question" rows="3" placeholder="What do you want the reviewer to check? (e.g., strengths, weaknesses)">{{ last_values.question or '' }}</textarea>
        </div>

        {% elif bot.id == "analyst" %}
        <div class="form-group">
            <label>Upload research paper (PDF)</label>
            <input type="file" id="analyst-file" name="pdf_file" accept="application/pdf">
        </div>
        <div class="form-group">
            <label>PDF URL or local path</label>
            <input type="text" id="analyst-path" name="pdf_path" value="{{ last_values.pdf_path or '' }}" placeholder="https://... or C:/path/to/file.pdf">
        </div>
        <div class="form-group">
            <p style="color:#999;">When you upload or paste a PDF/URL, the system will automatically analyze the paper and display a detailed summary.</p>
        </div>

        {% else %}
        <div class="form-group">
            <p style="color:#aaa;">Custom input fields not defined yet for this bot.</p>
        </div>
        {% endif %}

        <button type="submit" class="btn-primary" id="run-btn">
            <i class="fa-solid fa-play"></i> Run
        </button>
    </form>

    <div id="stream-area">
        <div class="result" id="result-box" style="display: none;">
            <h3>Result</h3>
            <pre id="result-pre">{% if result is not none %}{{ result }}{% endif %}</pre>
        </div>
    </div>

    {% if error %}
    <div class="result error">
        <strong>Error:</strong><br>{{ error }}
    </div>
    {% endif %}

<script>
// Intercept the form submit and stream the response from /bot/{bot.id}/stream
(function(){
    const form = document.querySelector('.tool-form');
    const runBtn = document.getElementById('run-btn');
    const resultBox = document.getElementById('result-box');
    const resultPre = document.getElementById('result-pre');

    // Generic run (for non-conference bots)
    form.addEventListener('submit', async function(e){
        // If on conference page, let the chat handlers manage interactions
        if (window.location.pathname.includes('/bot/conference')) {
            e.preventDefault();
            return; // do nothing - chat manages it
        }

        e.preventDefault();
        runBtn.disabled = true;
        resultBox.style.display = 'block';
        resultPre.textContent = '';

        const formData = new FormData(form);
        const resp = await fetch(window.location.pathname + '/stream', {
            method: 'POST',
            body: formData
        });

        if (!resp.ok) {
            const text = await resp.text();
            resultPre.textContent = 'Error: ' + text;
            runBtn.disabled = false;
            return;
        }

        // Stream reading
        const reader = resp.body.getReader();
        const decoder = new TextDecoder();
        let done = false;
        while (!done) {
            const {value, done: streamDone} = await reader.read();
            if (value) {
                resultPre.textContent += decoder.decode(value);
            }
            done = streamDone;
        }

        // After stream completes, render markdown (server-side sanitizer)
        try {
            const mdResp = await fetch('/render_markdown', { method: 'POST', body: new URLSearchParams({ md: resultPre.textContent }) });
            if (mdResp.ok){
                const html = await mdResp.text();
                resultPre.innerHTML = html;
            }
        } catch (e) { /* ignore */ }

        runBtn.disabled = false;
    });

    // Analyst: auto-run analysis when a file is selected or URL path input loses focus
    const analystFile = document.getElementById('analyst-file');
    const analystPath = document.getElementById('analyst-path');
    if (analystFile) {
        const autoAnalyze = async function(){
            // Submit the form (using stream endpoint) without a question to trigger automatic analysis
            resultBox.style.display = 'block';
            resultPre.textContent = 'Analyzing document...\n';
            const formData = new FormData(form);
            const resp = await fetch(window.location.pathname + '/stream', { method: 'POST', body: formData });
            if (!resp.ok){
                const t = await resp.text();
                resultPre.textContent = 'Error: ' + t;
                return;
            }
            const reader = resp.body.getReader();
            const decoder = new TextDecoder();
            let done = false;
            while (!done) {
                const {value, done: streamDone} = await reader.read();
                if (value) {
                    resultPre.textContent += decoder.decode(value);
                }
                done = streamDone;
            }
        };

        analystFile.addEventListener('change', autoAnalyze);
        analystPath && analystPath.addEventListener('blur', autoAnalyze);
    }

    // Conference-specific handlers (chat-only)
    if (window.location.pathname.includes('/bot/conference')){
        const chatWindow = document.getElementById('chat-window');
        const chatInput = document.getElementById('chat-input');
        const chatSend = document.getElementById('chat-send');

        function appendMsg(text, who='bot'){
            const p = document.createElement('div');
            p.style.margin = '6px 0';
            if (who === 'user'){
                p.innerHTML = `<div style="text-align:right; color:#d1e7ff">${text}</div>`;
            } else {
                p.innerHTML = `<div style="text-align:left">${text}</div>`;
            }
            chatWindow.appendChild(p);
            chatWindow.scrollTop = chatWindow.scrollHeight;
        }

        // Chat send button
        chatSend.addEventListener('click', async function(){
            const q = chatInput.value && chatInput.value.trim();
            if (!q) return;
            appendMsg(q, 'user');
            chatInput.value = '';

            // prepare minimal FormData with question only
            const formData = new FormData();
            formData.set('question', q);

            // show placeholder for bot
            appendMsg('â€¦', 'bot');
            const botPlaceholder = chatWindow.lastChild;

            const resp = await fetch(window.location.pathname + '/stream', {
                method: 'POST',
                body: formData
            });

            if (!resp.ok) {
                const text = await resp.text();
                botPlaceholder.innerHTML = `<div style="text-align:left">Error: ${text}</div>`;
                return;
            }

            const reader = resp.body.getReader();
            const decoder = new TextDecoder();
            let done = false;
            let partial = '';
            // accumulate streamed chunks into the last node
            while (!done){
                const {value, done: streamDone} = await reader.read();
                if (value) {
                    partial += decoder.decode(value);
                    botPlaceholder.innerHTML = `<div style="text-align:left">${partial}</div>`;
                    chatWindow.scrollTop = chatWindow.scrollHeight;
                }
                done = streamDone;
            }

            // Render the final markdown into sanitized HTML
            try{
                const mdResp = await fetch('/render_markdown', { method: 'POST', body: new URLSearchParams({ md: partial }) });
                if (mdResp.ok){
                    const html = await mdResp.text();
                    botPlaceholder.innerHTML = `<div style="text-align:left">${html}</div>`;
                }
            } catch(e) { /* ignore */ }
        });

        // Send on Enter
        chatInput.addEventListener('keydown', function(e){
            if (e.key === 'Enter'){
                e.preventDefault();
                chatSend.click();
            }
        });
    }
})();
</script>
</div>
{% endblock %}